package com.smirnov.project.lesson14.vehicle;

public class Task14 {
 /*   public static <T extends Vehicle, K extends T> K[] task01(T first, K second, Car car){
        // какие методы можно вызвать у second?

        //При сужении типа методами, доступными для вызова, являются методы данного типа, и по иерархии выше (т.е. супертипы),
        // При этом K фактически использует те же типы, что и Т т.е.
        //1) Доступны методы класс Object, напрмиер:
        second.hashCode();
        //2) Методы класса Vehicle и интерфейса Repairable
        second.repair();
        second.getNumber();
        second.getLevelOfWare();
        second.setNumber("");
        second.incLevelOfWare(10);
        second.breakDown();
        //Это вполне логично, т.к. в качестве параметра T мы можем указать любой подтип Vehicle (даже сам Vehicle)
        //И при создании абстрактного Vehicle было бы странно использовать дочерние методы


        // какие из аргументов можно добавить в массив, а какие нет и почему
        //

        *//*K[] arr = {};*//*
       *//* arr=null;
        return arr;*//*
    }*/
    public static void main(String[] args) {
         // Задание 1
        // какие типы можно указать в угловых скобках вместо ??? и
        // экземпляры каких классов передать?

        //экземпляр класса Car третьим аргументом можно передать всегда и в любом случае

        /*Task14.<Vehicle, Vehicle>task01(); //Здесь можно добавить все классы, т.к. они все сужают класс Vehicle, включая сам Vehicle
        Task14.<MiniCar, MiniCar >task01();*/ //Здесь можно добавить:
        // MiniCar,
        // Car, т.к. является родительским классом для Minicar и справедливо говорить, что MiniCar сужает тип Car
        //Vehicle, т.к. является родительским класс для последних двух
        /*Task14.<Train, Train>task01();*/

        //Для параметра T и параметра K можно передавать экземпляры класса того типа, который указывается в скобках и те, что находятся по иерархии ниже (наследников)
    }
}
